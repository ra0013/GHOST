#!/usr/bin/env python3
"""
GHOST GUI - Evidence-Focused Forensic Analysis Interface
Enhanced with Dynamic Configuration Integration
"""

import os
import sys
from pathlib import Path
import json
import datetime
import threading
import queue
import csv
from typing import Dict, List, Any, Optional

# GUI Framework
try:
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox, scrolledtext
    import tkinter.font as tkfont
except ImportError:
    print("Tkinter not available. Please install tkinter")
    sys.exit(1)

# Import the integrated configuration system
try:
    from config.integration import GHOSTIntegration, get_ghost_integration
    print("[OK] GHOST integration system loaded")
except ImportError:
    print("[ERROR] Could not load GHOST integration system")
    sys.exit(1)

# Import the forensic suite
try:
    from core.forensic_suite import FocusedForensicSuite
    print("[OK] Evidence analysis engine loaded")
except ImportError:
    print("[WARNING] Core forensic suite not available - using fallback mode")
    FocusedForensicSuite = None

class ForensicReportGenerator:
    """Generate professional forensic reports with integration support"""
    
    def __init__(self, case_name, examiner_name, analysis_results):
        self.case_name = case_name
        self.examiner_name = examiner_name
        self.analysis_results = analysis_results
        self.report_timestamp = datetime.datetime.now()
        
        # Get integration for configuration access
        self.integration = get_ghost_integration()
    
    def generate_executive_summary_report(self):
        """Generate executive summary report with enhanced configuration"""
        if not self.analysis_results:
            return "No analysis data available for report generation."
        
        exec_summary = self.analysis_results.get('executive_summary', {})
        evidence_summary = self.analysis_results.get('evidence_summary', {})
        
        # Get case information from integration
        case_info = self.integration.export_case_info() if hasattr(self.integration, 'export_case_info') else {}
        
        report = f"""GHOST FORENSIC ANALYSIS - EXECUTIVE SUMMARY
{'=' * 60}

CASE INFORMATION:
‚Ä¢ Case Name: {self.case_name}
‚Ä¢ Examiner: {self.examiner_name}
‚Ä¢ Analysis Date: {self.report_timestamp.strftime('%Y-%m-%d %H:%M:%S')}
‚Ä¢ Tool: GHOST Evidence Analysis Interface with Dynamic Configuration
‚Ä¢ Configuration Version: {case_info.get('tool_version', 'Unknown')}

PRIORITY ASSESSMENT:
‚Ä¢ Level: {exec_summary.get('priority_level', 'Unknown')}
‚Ä¢ Reason: {exec_summary.get('priority_reason', 'Not specified')}

EVIDENCE SUMMARY:
‚Ä¢ Messages Found: {evidence_summary.get('communications', {}).get('messages', 0)}
‚Ä¢ Calls Found: {evidence_summary.get('communications', {}).get('calls', 0)}
‚Ä¢ Contacts Found: {evidence_summary.get('communications', {}).get('contacts', 0)}
‚Ä¢ Photos Found: {evidence_summary.get('multimedia', {}).get('photos', 0)}
‚Ä¢ Videos Found: {evidence_summary.get('multimedia', {}).get('videos', 0)}
‚Ä¢ Location Points: {evidence_summary.get('digital_activity', {}).get('location_points', 0)}

EVIDENCE TYPES FOUND:
"""
        
        evidence_types = exec_summary.get('evidence_types_found', [])
        for evidence_type in evidence_types:
            report += f"‚Ä¢ {evidence_type}\n"
        
        report += "\nIMMEDIATE ACTIONS REQUIRED:\n"
        actions = exec_summary.get('immediate_actions', [])
        for action in actions:
            report += f"‚Ä¢ {action}\n"
        
        # Add investigative leads
        leads = self.analysis_results.get('investigative_leads', [])
        if leads:
            report += f"\nINVESTIGATIVE LEADS ({len(leads)}):\n"
            for i, lead in enumerate(leads[:10], 1):
                report += f"{i}. {lead.get('type', 'Unknown')} - {lead.get('priority', 'Medium')}\n"
                report += f"   {lead.get('description', 'No description')}\n"
                report += f"   Action: {lead.get('action_required', 'No action specified')}\n\n"
        
        # Add configuration-based analysis
        modules_config = self.integration.get_analysis_modules_config()
        enabled_modules = [name for name, config in modules_config.items() if config.get('enabled', True)]
        
        report += f"\nANALYSIS CONFIGURATION:\n"
        report += f"‚Ä¢ Enabled Modules: {', '.join(enabled_modules)}\n"
        report += f"‚Ä¢ Total Keywords: {sum(len(self.integration.get_intelligence_keywords(mod)) for mod in enabled_modules)}\n"
        
        report += f"\n\nReport generated by GHOST Evidence Analysis Interface\nTimestamp: {self.report_timestamp.isoformat()}"
        
        return report

class IntegratedEvidenceAnalysisGUI:
    """Evidence-focused GUI with GHOST integration support"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.setup_main_window()
        
        # Initialize GHOST integration
        try:
            self.integration = get_ghost_integration()
            print("[OK] GHOST integration initialized")
        except Exception as e:
            print(f"[ERROR] GHOST integration failed: {e}")
            messagebox.showerror("Integration Error", 
                               f"Failed to initialize GHOST integration: {e}")
            sys.exit(1)
        
        # Application state
        self.case_name = tk.StringVar()
        self.examiner_name = tk.StringVar()
        self.extraction_path = tk.StringVar()
        
        # Analysis state
        self.analysis_thread = None
        self.analysis_results = None
        self.progress_queue = queue.Queue()
        self.status_queue = queue.Queue()
        
        # Status variables
        self.status_var = tk.StringVar(value="Ready for evidence analysis with GHOST integration")
        self.progress_var = tk.DoubleVar()
        self.time_var = tk.StringVar()
        
        # Create interface
        self.setup_styling()
        self.create_widgets()
        
        # Start update loops
        self.update_time()
        self.check_queues()
        
        print("[OK] GHOST GUI initialized with integration support")
    
    def setup_main_window(self):
        """Configure main window"""
        self.root.title("GHOST - Evidence Analysis Interface (Integrated)")
        self.root.geometry("1200x800")
        self.root.minsize(1000, 600)
        
        # Configure responsive design
        self.root.grid_rowconfigure(0, weight=1)
        self.root.grid_columnconfigure(0, weight=1)
        
        # Handle window close
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def setup_styling(self):
        """Configure modern styling"""
        self.style = ttk.Style()
        
        try:
            self.style.theme_use('clam')
        except:
            self.style.theme_use('default')
        
        # Evidence-focused color scheme
        colors = {
            'primary': '#2E4A72',      # Investigation blue
            'accent': '#C7102E',       # Alert red
            'success': '#228B22',      # Evidence green
            'text': '#333333'          # Dark gray
        }
        
        # Configure styles
        self.style.configure('Title.TLabel', 
                           font=('Arial', 16, 'bold'), 
                           foreground=colors['primary'])
        
        self.style.configure('Header.TLabel', 
                           font=('Arial', 12, 'bold'), 
                           foreground=colors['text'])
        
        self.style.configure('Evidence.TLabel',
                           font=('Arial', 10, 'bold'),
                           foreground=colors['success'])
        
        self.style.configure('Alert.TLabel',
                           font=('Arial', 10, 'bold'),
                           foreground=colors['accent'])
    
    def create_widgets(self):
        """Create all GUI widgets"""
        # Main container
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky="nsew")
        main_frame.grid_rowconfigure(1, weight=1)
        main_frame.grid_columnconfigure(0, weight=1)
        
        # Title bar
        self.create_title_bar(main_frame)
        
        # Main notebook for tabs
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.grid(row=1, column=0, sticky="nsew", pady=(10, 0))
        
        # Create tabs
        self.create_case_setup_tab()
        self.create_evidence_overview_tab()
        self.create_communications_tab()
        self.create_multimedia_tab()
        self.create_apps_locations_tab()
        self.create_configuration_tab()  # New configuration tab
        self.create_report_tab()
        
        # Status bar
        self.create_status_bar(main_frame)
    
    def create_title_bar(self, parent):
        """Create title bar"""
        title_frame = ttk.Frame(parent)
        title_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        title_frame.grid_columnconfigure(1, weight=1)
        
        # Main title
        title = ttk.Label(title_frame, 
                         text="GHOST - Evidence Analysis Interface (Integrated)", 
                         style='Title.TLabel')
        title.grid(row=0, column=0, sticky="w")
        
        # Subtitle with integration info
        subtitle = ttk.Label(title_frame, 
                           text="Golden Hour Operations with Dynamic Configuration")
        subtitle.grid(row=0, column=1, sticky="e")
    
    def create_case_setup_tab(self):
        """Create case setup and analysis tab with integration features"""
        case_frame = ttk.Frame(self.notebook, padding="20")
        self.notebook.add(case_frame, text="Case Setup")
        
        case_frame.grid_columnconfigure(0, weight=1)
        
        # Case Information
        info_frame = ttk.LabelFrame(case_frame, text="Case Information", padding="15")
        info_frame.grid(row=0, column=0, sticky="ew", pady=(0, 20))
        info_frame.grid_columnconfigure(1, weight=1)
        
        # Case name
        ttk.Label(info_frame, text="Case Name:", style='Header.TLabel').grid(
            row=0, column=0, sticky="w", pady=(0, 10))
        case_entry = ttk.Entry(info_frame, textvariable=self.case_name, width=40)
        case_entry.grid(row=0, column=1, sticky="ew", padx=(10, 0), pady=(0, 10))
        
        # Examiner
        ttk.Label(info_frame, text="Examiner:", style='Header.TLabel').grid(
            row=1, column=0, sticky="w", pady=(0, 10))
        examiner_entry = ttk.Entry(info_frame, textvariable=self.examiner_name, width=40)
        examiner_entry.grid(row=1, column=1, sticky="ew", padx=(10, 0), pady=(0, 10))
        
        # Extraction path
        ttk.Label(info_frame, text="Extraction Path:", style='Header.TLabel').grid(
            row=2, column=0, sticky="w")
        
        path_frame = ttk.Frame(info_frame)
        path_frame.grid(row=2, column=1, sticky="ew", padx=(10, 0))
        path_frame.grid_columnconfigure(0, weight=1)
        
        path_entry = ttk.Entry(path_frame, textvariable=self.extraction_path)
        path_entry.grid(row=0, column=0, sticky="ew", padx=(0, 10))
        
        ttk.Button(path_frame, text="Browse...", command=self.browse_extraction).grid(row=0, column=1)
        
        # File type indicator with platform detection
        self.file_type_var = tk.StringVar(value="No extraction selected")
        ttk.Label(info_frame, textvariable=self.file_type_var).grid(
            row=3, column=1, sticky="w", padx=(10, 0), pady=(5, 0))
        
        # Platform detection display
        self.platform_var = tk.StringVar(value="Platform: Unknown")
        ttk.Label(info_frame, textvariable=self.platform_var).grid(
            row=4, column=1, sticky="w", padx=(10, 0), pady=(5, 0))
        
        # Analysis Controls with configuration info
        analysis_frame = ttk.LabelFrame(case_frame, text="Evidence Analysis with GHOST Integration", padding="15")
        analysis_frame.grid(row=1, column=0, sticky="ew", pady=(0, 20))
        
        # Configuration status
        config_status_frame = ttk.Frame(analysis_frame)
        config_status_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        analysis_frame.grid_columnconfigure(0, weight=1)
        
        validation_results = self.integration.validate_configuration()
        config_status = "‚úì Configuration Valid" if not validation_results.get('errors') else "‚ö† Configuration Issues"
        config_color = 'green' if not validation_results.get('errors') else 'red'
        
        config_label = tk.Label(config_status_frame, text=config_status, fg=config_color, font=('Arial', 10, 'bold'))
        config_label.pack(side="left")
        
        # Show enabled modules
        modules_config = self.integration.get_analysis_modules_config()
        enabled_modules = [name for name, config in modules_config.items() if config.get('enabled', True)]
        
        modules_label = tk.Label(config_status_frame, 
                               text=f"Active Modules: {len(enabled_modules)}", 
                               font=('Arial', 9))
        modules_label.pack(side="right")
        
        # Progress bar
        self.progress_bar = ttk.Progressbar(analysis_frame, variable=self.progress_var, 
                                          mode='determinate')
        self.progress_bar.grid(row=1, column=0, sticky="ew", pady=(0, 10))
        
        # Control buttons
        button_frame = ttk.Frame(analysis_frame)
        button_frame.grid(row=2, column=0, sticky="ew")
        
        self.analyze_btn = ttk.Button(button_frame, text="Start Integrated Analysis", 
                                     command=self.start_evidence_analysis)
        self.analyze_btn.pack(side="left", padx=(0, 10))
        
        self.cancel_btn = ttk.Button(button_frame, text="Cancel", 
                                    command=self.cancel_analysis, state="disabled")
        self.cancel_btn.pack(side="left", padx=(0, 10))
        
        ttk.Button(button_frame, text="Save Case", 
                  command=self.save_case).pack(side="left", padx=(0, 10))
        ttk.Button(button_frame, text="Load Case", 
                  command=self.load_case).pack(side="left", padx=(0, 10))
        
        # Test Configuration button
        ttk.Button(button_frame, text="Test Config", 
                  command=self.test_configuration).pack(side="left")
        
        # Analysis Status
        status_frame = ttk.LabelFrame(case_frame, text="Analysis Status", padding="15")
        status_frame.grid(row=2, column=0, sticky="ew")
        
        self.analysis_status_text = scrolledtext.ScrolledText(status_frame, height=8, font=('Consolas', 9))
        self.analysis_status_text.pack(fill="both", expand=True)
        
        # Add initial status message
        self.log_analysis_message("GHOST integration ready - dynamic configuration loaded")
    
    def create_configuration_tab(self):
        """Create configuration management tab"""
        config_frame = ttk.Frame(self.notebook, padding="20")
        self.notebook.add(config_frame, text="Configuration")
        
        config_frame.grid_rowconfigure(1, weight=1)
        config_frame.grid_columnconfigure(0, weight=1)
        
        # Configuration info
        info_frame = ttk.LabelFrame(config_frame, text="GHOST Configuration Status", padding="15")
        info_frame.grid(row=0, column=0, sticky="ew", pady=(0, 20))
        
        # Validation results
        validation_results = self.integration.validate_configuration()
        
        status_text = "Configuration Status:\n"
        if validation_results.get('errors'):
            status_text += "‚ùå Errors Found:\n"
            for error in validation_results['errors']:
                status_text += f"  ‚Ä¢ {error}\n"
        else:
            status_text += "‚úÖ No errors found\n"
        
        if validation_results.get('warnings'):
            status_text += "\n‚ö†Ô∏è Warnings:\n"
            for warning in validation_results['warnings']:
                status_text += f"  ‚Ä¢ {warning}\n"
        
        if validation_results.get('suggestions'):
            status_text += "\nüí° Suggestions:\n"
            for suggestion in validation_results['suggestions']:
                status_text += f"  ‚Ä¢ {suggestion}\n"
        
        status_label = tk.Label(info_frame, text=status_text, justify="left", font=('Consolas', 9))
        status_label.pack(anchor="w")
        
        # Configuration display
        config_display_frame = ttk.LabelFrame(config_frame, text="Current Configuration", padding="15")
        config_display_frame.grid(row=1, column=0, sticky="nsew")
        config_display_frame.grid_rowconfigure(0, weight=1)
        config_display_frame.grid_columnconfigure(0, weight=1)
        
        self.config_text = scrolledtext.ScrolledText(config_display_frame, font=('Consolas', 9))
        self.config_text.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        
        # Load current configuration
        self.update_configuration_display()
        
        # Configuration controls
        controls_frame = ttk.Frame(config_frame)
        controls_frame.grid(row=2, column=0, sticky="ew", pady=(10, 0))
        
        ttk.Button(controls_frame, text="Refresh Config", 
                  command=self.update_configuration_display).pack(side="left", padx=(0, 10))
        ttk.Button(controls_frame, text="Export Config", 
                  command=self.export_configuration).pack(side="left", padx=(0, 10))
        ttk.Button(controls_frame, text="Validate Config", 
                  command=self.test_configuration).pack(side="left")

    def update_configuration_display(self):
        """Update configuration display"""
        try:
            config_info = "GHOST CONFIGURATION OVERVIEW\n"
            config_info += "=" * 40 + "\n\n"
            
            # Get enabled modules
            modules_config = self.integration.get_analysis_modules_config()
            config_info += f"ENABLED MODULES ({len(modules_config)}):\n"
            for module_name, module_config in modules_config.items():
                priority = module_config.get('priority', 'medium')
                enabled = module_config.get('enabled', True)
                status = "‚úì" if enabled else "‚úó"
                config_info += f"  {status} {module_name} (Priority: {priority})\n"
            
            # Get database paths configuration
            paths_config = self.integration.get_database_paths()
            config_info += f"\nCONFIGURED DATA PATHS:\n"
            for data_type, paths in list(paths_config.items())[:5]:  # Show first 5
                if isinstance(paths, list):
                    config_info += f"  {data_type}: {len(paths)} paths\n"
                else:
                    config_info += f"  {data_type}: {paths}\n"
            
            # Get keywords summary
            config_info += f"\nINTELLIGENCE KEYWORDS:\n"
            for module_name in modules_config.keys():
                keywords = self.integration.get_intelligence_keywords(module_name)
                if keywords:
                    total_keywords = sum(len(kw_list) for kw_list in keywords.values() if isinstance(kw_list, list))
                    config_info += f"  {module_name}: {total_keywords} keywords\n"
            
            # Validation status
            validation_results = self.integration.validate_configuration()
            config_info += f"\nVALIDATION STATUS:\n"
            config_info += f"  Errors: {len(validation_results.get('errors', []))}\n"
            config_info += f"  Warnings: {len(validation_results.get('warnings', []))}\n"
            config_info += f"  Suggestions: {len(validation_results.get('suggestions', []))}\n"
            
            self.config_text.delete("1.0", tk.END)
            self.config_text.insert("1.0", config_info)
            
        except Exception as e:
            error_msg = f"Error loading configuration display: {e}"
            self.config_text.delete("1.0", tk.END)
            self.config_text.insert("1.0", error_msg)

    def export_configuration(self):
        """Export current configuration"""
        try:
            filename = filedialog.asksaveasfilename(
                defaultextension=".json",
                filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
                title="Export GHOST Configuration"
            )
            
            if filename:
                export_file = self.integration.config.export_configuration(filename)
                messagebox.showinfo("Success", f"Configuration exported to {export_file}")
                
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export configuration: {e}")

    def test_configuration(self):
        """Test current configuration"""
        try:
            validation_results = self.integration.validate_configuration()
            
            if not validation_results.get('errors'):
                messagebox.showinfo("Configuration Valid", 
                                  "‚úÖ Configuration is valid and ready for use!")
            else:
                error_msg = "Configuration Issues Found:\n\n"
                for error in validation_results['errors']:
                    error_msg += f"‚Ä¢ {error}\n"
                
                if validation_results.get('warnings'):
                    error_msg += "\nWarnings:\n"
                    for warning in validation_results['warnings']:
                        error_msg += f"‚Ä¢ {warning}\n"
                
                messagebox.showwarning("Configuration Issues", error_msg)
                
        except Exception as e:
            messagebox.showerror("Test Error", f"Failed to test configuration: {e}")
    
    def browse_extraction(self):
        """Browse for extraction path with platform detection"""
        # Allow both files and directories
        file_path = filedialog.askopenfilename(
            title="Select Extraction ZIP File",
            filetypes=[("ZIP files", "*.zip"), ("All files", "*.*")]
        )
        
        if not file_path:
            dir_path = filedialog.askdirectory(title="Select Extraction Directory")
            if dir_path:
                file_path = dir_path
        
        if file_path:
            self.extraction_path.set(file_path)
            
            # Update file type indicator with platform detection
            path_obj = Path(file_path)
            if path_obj.is_file() and path_obj.suffix.lower() == '.zip':
                size_mb = path_obj.stat().st_size / (1024 * 1024)
                self.file_type_var.set(f"ZIP file selected ({size_mb:.1f} MB)")
            elif path_obj.is_dir():
                self.file_type_var.set("Directory selected")
            else:
                self.file_type_var.set("File selected")
            
            # Detect platform using integration
            if path_obj.exists():
                try:
                    case_config = self.integration.create_case_specific_config("temp_case", path_obj)
                    platform = case_config.get('platform', 'Unknown')
                    self.platform_var.set(f"Platform: {platform}")
                    
                    if platform != 'Unknown':
                        self.log_analysis_message(f"Detected platform: {platform}")
                except Exception as e:
                    self.platform_var.set("Platform: Detection failed")
                    self.log_analysis_message(f"Platform detection error: {e}")

    def start_evidence_analysis(self):
        """Start evidence analysis with integration support"""
        if not self.validate_case_info():
            return
        
        # Confirm analysis
        if not messagebox.askyesno("Start Analysis", 
                                  "Start integrated evidence analysis? This may take several minutes."):
            return
        
        # Test configuration before starting
        validation_results = self.integration.validate_configuration()
        if validation_results.get('errors'):
            if not messagebox.askyesno("Configuration Issues", 
                                     f"Configuration has errors: {validation_results['errors']}\n\nContinue anyway?"):
                return
        
        # Prepare for analysis
        self.analyze_btn.config(state="disabled")
        self.cancel_btn.config(state="normal")
        self.progress_var.set(0)
        self.clear_analysis_log()
        
        # Start analysis thread
        self.analysis_thread = threading.Thread(target=self.analysis_worker, daemon=True)
        self.analysis_thread.start()
    
    def analysis_worker(self):
        """Background analysis worker with integration"""
        try:
            # Update status
            self.status_queue.put({'message': 'Initializing integrated evidence analysis...'})
            self.progress_queue.put({'progress': 5, 'message': 'Starting integrated analysis...'})
            
            # Create case-specific configuration
            extraction_path = Path(self.extraction_path.get())
            case_config = self.integration.create_case_specific_config(
                self.case_name.get(), 
                extraction_path
            )
            
            self.progress_queue.put({'progress': 10, 'message': 'Case configuration created'})
            
            # Initialize forensic suite with integration
            if FocusedForensicSuite:
                suite = FocusedForensicSuite(self.case_name.get(), self.examiner_name.get())
                
                # Pass integration configuration to suite
                suite.integration = self.integration
                suite.case_config = case_config
                
                self.progress_queue.put({'progress': 20, 'message': 'Forensic suite initialized with configuration'})
                
                # Run analysis
                self.progress_queue.put({'progress': 30, 'message': 'Running evidence analysis...'})
                report = suite.analyze_extraction(self.extraction_path.get())
                
                # Enhance report with configuration data
                report['configuration_info'] = {
                    'modules_used': list(self.integration.get_analysis_modules_config().keys()),
                    'platform_detected': case_config.get('platform', 'Unknown'),
                    'total_keywords': sum(
                        len(self.integration.get_intelligence_keywords(mod)) 
                        for mod in self.integration.get_analysis_modules_config().keys()
                    )
                }
                
                self.progress_queue.put({'progress': 90, 'message': 'Analysis complete, generating report...'})
                
            else:
                # Fallback mode without forensic suite
                report = self._generate_demo_report_with_integration()
                self.progress_queue.put({'progress': 90, 'message': 'Demo analysis complete...'})
            
            # Update UI on main thread
            self.root.after(0, lambda: self.update_analysis_results(report))
            self.progress_queue.put({'progress': 100, 'message': 'Integrated analysis complete!'})
            
        except Exception as e:
            error_msg = f"Integrated analysis failed: {str(e)}"
            self.root.after(0, lambda: self.analysis_error(error_msg))
        
        finally:
            # Re-enable controls
            self.root.after(0, self.analysis_complete)

    def _generate_demo_report_with_integration(self):
        """Generate demo report with integration features"""
        modules_config = self.integration.get_analysis_modules_config()
        
        return {
            'case_information': {
                'case_name': self.case_name.get(),
                'examiner': self.examiner_name.get(),
                'analysis_date': datetime.datetime.now().isoformat(),
                'source_path': self.extraction_path.get(),
                'tool_version': 'GHOST Evidence Analysis Interface (Integrated Demo Mode)'
            },
            'executive_summary': {
                'priority_level': 'DEMO MODE',
                'priority_reason': 'Using integration demo with configured modules',
                'evidence_types_found': [
                    'Demo Messages (15)',
                    'Demo Calls (8)', 
                    'Demo Photos (25)',
                ],
                'key_statistics': {
                    'total_communications': 23,
                    'unique_contacts': 7,
                    'investigation_keywords': len(modules_config) * 10,  # Simulated
                    'multimedia_files': 30,
                    'location_points': 45
                },
                'immediate_actions': [
                    'Review integration configuration',
                    'Run full analysis with configured modules',
                    f'Examine data using {len(modules_config)} enabled intelligence modules'
                ]
            },
            'evidence_summary': {
                'communications': {'messages': 15, 'calls': 8, 'contacts': 7},
                'multimedia': {'photos': 25, 'videos': 5},
                'digital_activity': {'location_points': 45, 'app_data': 3, 'browser_records': 12, 'databases': 4}
            },
            'configuration_info': {
                'modules_used': list(modules_config.keys()),
                'platform_detected': 'Demo Platform',
                'total_keywords': sum(
                    len(self.integration.get_intelligence_keywords(mod)) 
                    for mod in modules_config.keys()
                )
            },
            'investigative_leads': [
                {
                    'type': 'Configuration Demo',
                    'priority': 'Medium',
                    'description': 'Integration system is working with configured modules',
                    'action_required': 'Run full analysis with real data'
                }
            ],
            'raw_evidence_data': {
                'messages': [],
                'calls': [],
                'contacts': [],
                'photos': [],
                'videos': [],
                'locations': [],
                'apps': {},
                'browsers': [],
                'databases': []
            }
        }

    # Include all the original GUI methods from the base class
    def create_evidence_overview_tab(self):
        """Create evidence overview tab"""
        overview_frame = ttk.Frame(self.notebook, padding="20")
        self.notebook.add(overview_frame, text="Evidence Overview")
        
        # Summary cards
        cards_frame = ttk.Frame(overview_frame)
        cards_frame.pack(fill="x", pady=(0, 20))
        
        self.evidence_cards = {}
        card_data = [
            ("Messages", "0"),
            ("Calls", "0"), 
            ("Photos", "0"),
            ("Apps", "0"),
            ("Locations", "0"),
            ("Alerts", "0")
        ]
        
        for i, (title, value) in enumerate(card_data):
            card = self.create_evidence_card(cards_frame, title, value)
            card.grid(row=0, column=i, padx=5, sticky="ew")
            self.evidence_cards[title] = card
            cards_frame.grid_columnconfigure(i, weight=1)
        
        # Executive Summary
        exec_frame = ttk.LabelFrame(overview_frame, text="Executive Summary")
        exec_frame.pack(fill="both", expand=True)
        
        self.executive_summary_text = scrolledtext.ScrolledText(exec_frame, font=('Arial', 10))
        self.executive_summary_text.pack(fill="both", expand=True, padx=10, pady=10)
    
    def create_evidence_card(self, parent, title, value):
        """Create evidence summary card"""
        card_frame = ttk.LabelFrame(parent, text=title)
        
        # Value label
        value_label = ttk.Label(card_frame, text=value, font=('Arial', 18, 'bold'))
        value_label.pack(pady=10)
        
        # Store reference to value label for updates
        card_frame.value_label = value_label
        
        return card_frame
    
    def create_communications_tab(self):
        """Create communications analysis tab"""
        comm_frame = ttk.Frame(self.notebook, padding="20")
        self.notebook.add(comm_frame, text="Communications")
        
        comm_frame.grid_rowconfigure(1, weight=1)
        comm_frame.grid_columnconfigure(0, weight=1)
        
        # Controls
        controls = ttk.Frame(comm_frame)
        controls.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        
        ttk.Button(controls, text="Export Messages", 
                  command=self.export_messages_csv).pack(side="left", padx=(0, 10))
        ttk.Button(controls, text="Export Calls", 
                  command=self.export_calls_csv).pack(side="left", padx=(0, 10))
        ttk.Button(controls, text="Export Contacts", 
                  command=self.export_contacts_csv).pack(side="left", padx=(0, 10))
        ttk.Button(controls, text="View Timeline", 
                  command=self.view_timeline).pack(side="left")
        
        # Communications notebook
        comm_notebook = ttk.Notebook(comm_frame)
        comm_notebook.grid(row=1, column=0, sticky="nsew")
        
        # Messages tab
        messages_frame = ttk.Frame(comm_notebook)
        comm_notebook.add(messages_frame, text="Messages")
        self.create_messages_view(messages_frame)
        
        # Calls tab
        calls_frame = ttk.Frame(comm_notebook)
        comm_notebook.add(calls_frame, text="Calls")
        self.create_calls_view(calls_frame)
        
        # Contacts tab
        contacts_frame = ttk.Frame(comm_notebook)
        comm_notebook.add(contacts_frame, text="Contacts")
        self.create_contacts_view(contacts_frame)
    
    def create_messages_view(self, parent):
        """Create messages view"""
        parent.grid_rowconfigure(0, weight=1)
        parent.grid_columnconfigure(0, weight=1)
        
        # Messages treeview
        columns = ("Timestamp", "Contact", "Direction", "Message", "Keywords")
        self.messages_tree = ttk.Treeview(parent, columns=columns, show="headings")
        
        for col in columns:
            self.messages_tree.heading(col, text=col)
            if col == "Message":
                self.messages_tree.column(col, width=300)
            else:
                self.messages_tree.column(col, width=120)
        
        # Scrollbars
        msg_v_scroll = ttk.Scrollbar(parent, orient="vertical", command=self.messages_tree.yview)
        msg_h_scroll = ttk.Scrollbar(parent, orient="horizontal", command=self.messages_tree.xview)
        self.messages_tree.configure(yscrollcommand=msg_v_scroll.set, xscrollcommand=msg_h_scroll.set)
        
        # Grid layout
        self.messages_tree.grid(row=0, column=0, sticky="nsew", padx=(10, 0), pady=10)
        msg_v_scroll.grid(row=0, column=1, sticky="ns", pady=10)
        msg_h_scroll.grid(row=1, column=0, sticky="ew", padx=(10, 0))
    
    def create_calls_view(self, parent):
        """Create calls view"""
        parent.grid_rowconfigure(0, weight=1)
        parent.grid_columnconfigure(0, weight=1)
        
        # Calls treeview
        columns = ("Timestamp", "Contact", "Duration", "Type")
        self.calls_tree = ttk.Treeview(parent, columns=columns, show="headings")
        
        for col in columns:
            self.calls_tree.heading(col, text=col)
            self.calls_tree.column(col, width=150)
        
        # Scrollbars
        call_v_scroll = ttk.Scrollbar(parent, orient="vertical", command=self.calls_tree.yview)
        self.calls_tree.configure(yscrollcommand=call_v_scroll.set)
        
        # Grid layout
        self.calls_tree.grid(row=0, column=0, sticky="nsew", padx=(10, 0), pady=10)
        call_v_scroll.grid(row=0, column=1, sticky="ns", pady=10)
    
    def create_contacts_view(self, parent):
        """Create contacts view"""
        parent.grid_rowconfigure(0, weight=1)
        parent.grid_columnconfigure(0, weight=1)
        
        # Contacts treeview
        columns = ("Name", "Phone", "Messages", "Calls", "Last Contact")
        self.contacts_tree = ttk.Treeview(parent, columns=columns, show="headings")
        
        for col in columns:
            self.contacts_tree.heading(col, text=col)
            self.contacts_tree.column(col, width=150)
        
        # Scrollbar
        contact_scroll = ttk.Scrollbar(parent, orient="vertical", command=self.contacts_tree.yview)
        self.contacts_tree.configure(yscrollcommand=contact_scroll.set)
        
        # Grid layout
        self.contacts_tree.grid(row=0, column=0, sticky="nsew", padx=(10, 0), pady=10)
        contact_scroll.grid(row=0, column=1, sticky="ns", pady=10)
    
    def create_multimedia_tab(self):
        """Create multimedia evidence tab"""
        media_frame = ttk.Frame(self.notebook, padding="20")
        self.notebook.add(media_frame, text="Photos & Videos")
        
        media_frame.grid_rowconfigure(1, weight=1)
        media_frame.grid_columnconfigure(0, weight=1)
        
        # Controls
        controls = ttk.Frame(media_frame)
        controls.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        
        ttk.Button(controls, text="Export Multimedia List", 
                  command=self.export_multimedia_csv).pack(side="left", padx=(0, 10))
        
        # Media notebook
        media_notebook = ttk.Notebook(media_frame)
        media_notebook.grid(row=1, column=0, sticky="nsew")
        
        # Photos tab
        photos_frame = ttk.Frame(media_notebook)
        media_notebook.add(photos_frame, text="Photos")
        self.create_media_view(photos_frame, "photos")
        
        # Videos tab
        videos_frame = ttk.Frame(media_notebook)
        media_notebook.add(videos_frame, text="Videos")
        self.create_media_view(videos_frame, "videos")
    
    def create_media_view(self, parent, media_type):
        """Create media file view"""
        parent.grid_rowconfigure(0, weight=1)
        parent.grid_columnconfigure(0, weight=1)
        
        # Media treeview
        columns = ("Filename", "Size", "Date Modified", "Path")
        tree = ttk.Treeview(parent, columns=columns, show="headings")
        
        for col in columns:
            tree.heading(col, text=col)
            if col == "Path":
                tree.column(col, width=300)
            else:
                tree.column(col, width=150)
        
        # Store tree reference
        if media_type == "photos":
            self.photos_tree = tree
        else:
            self.videos_tree = tree
        
        # Scrollbars
        v_scroll = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
        h_scroll = ttk.Scrollbar(parent, orient="horizontal", command=tree.xview)
        tree.configure(yscrollcommand=v_scroll.set, xscrollcommand=h_scroll.set)
        
        # Grid layout
        tree.grid(row=0, column=0, sticky="nsew", padx=(10, 0), pady=10)
        v_scroll.grid(row=0, column=1, sticky="ns", pady=10)
        h_scroll.grid(row=1, column=0, sticky="ew", padx=(10, 0))
    
    def create_apps_locations_tab(self):
        """Create apps and locations tab"""
        apps_frame = ttk.Frame(self.notebook, padding="20")
        self.notebook.add(apps_frame, text="Apps & Locations")
        
        apps_frame.grid_rowconfigure(0, weight=1)
        apps_frame.grid_columnconfigure(0, weight=1)
        
        # Apps and locations notebook
        apps_notebook = ttk.Notebook(apps_frame)
        apps_notebook.grid(row=0, column=0, sticky="nsew")
        
        # Apps tab
        apps_tab_frame = ttk.Frame(apps_notebook)
        apps_notebook.add(apps_tab_frame, text="App Data")
        self.create_apps_view(apps_tab_frame)
        
        # Locations tab
        locations_frame = ttk.Frame(apps_notebook)
        apps_notebook.add(locations_frame, text="Location Data")
        self.create_locations_view(locations_frame)
    
    def create_apps_view(self, parent):
        """Create apps view"""
        parent.grid_rowconfigure(1, weight=1)
        parent.grid_columnconfigure(0, weight=1)
        
        # Controls
        controls = ttk.Frame(parent)
        controls.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        
        ttk.Button(controls, text="Export App Data", 
                  command=self.export_app_data).pack(side="left")
        
        # Apps treeview
        columns = ("App Name", "Files Found", "Priority", "Data Available")
        self.apps_tree = ttk.Treeview(parent, columns=columns, show="headings")
        
        for col in columns:
            self.apps_tree.heading(col, text=col)
            self.apps_tree.column(col, width=150)
        
        # Scrollbar
        apps_scroll = ttk.Scrollbar(parent, orient="vertical", command=self.apps_tree.yview)
        self.apps_tree.configure(yscrollcommand=apps_scroll.set)
        
        # Grid layout
        self.apps_tree.grid(row=1, column=0, sticky="nsew", padx=(10, 0), pady=10)
        apps_scroll.grid(row=1, column=1, sticky="ns", pady=10)
    
    def create_locations_view(self, parent):
        """Create locations view"""
        parent.grid_rowconfigure(1, weight=1)
        parent.grid_columnconfigure(0, weight=1)
        
        # Controls
        controls = ttk.Frame(parent)
        controls.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        
        ttk.Button(controls, text="Export Locations", 
                  command=self.export_locations_csv).pack(side="left", padx=(0, 10))
        ttk.Button(controls, text="View Map", 
                  command=self.view_map).pack(side="left")
        
        # Locations treeview
        columns = ("Timestamp", "Latitude", "Longitude", "Accuracy")
        self.locations_tree = ttk.Treeview(parent, columns=columns, show="headings")
        
        for col in columns:
            self.locations_tree.heading(col, text=col)
            self.locations_tree.column(col, width=150)
        
        # Scrollbar
        loc_scroll = ttk.Scrollbar(parent, orient="vertical", command=self.locations_tree.yview)
        self.locations_tree.configure(yscrollcommand=loc_scroll.set)
        
        # Grid layout
        self.locations_tree.grid(row=1, column=0, sticky="nsew", padx=(10, 0), pady=10)
        loc_scroll.grid(row=1, column=1, sticky="ns", pady=10)
    
    def create_report_tab(self):
        """Create report and export tab"""
        report_frame = ttk.Frame(self.notebook, padding="20")
        self.notebook.add(report_frame, text="Reports & Export")
        
        report_frame.grid_rowconfigure(1, weight=1)
        report_frame.grid_columnconfigure(0, weight=1)
        
        # Export controls
        export_frame = ttk.Frame(report_frame)
        export_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        
        ttk.Button(export_frame, text="Export Full Report (JSON)", 
                  command=self.export_full_report).pack(side="left", padx=(0, 10))
        ttk.Button(export_frame, text="Export Executive Summary", 
                  command=self.export_executive_summary_txt).pack(side="left", padx=(0, 10))
        ttk.Button(export_frame, text="Export Detailed Report", 
                  command=self.export_detailed_report_txt).pack(side="left", padx=(0, 10))
        ttk.Button(export_frame, text="Export All Data Package", 
                  command=self.export_all_data_package).pack(side="left")
        
        # Report display
        report_label_frame = ttk.LabelFrame(report_frame, text="Generated Report")
        report_label_frame.grid(row=1, column=0, sticky="nsew")
        report_label_frame.grid_rowconfigure(0, weight=1)
        report_label_frame.grid_columnconfigure(0, weight=1)
        
        self.report_text = scrolledtext.ScrolledText(report_label_frame, font=('Consolas', 9))
        self.report_text.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
    
    def create_status_bar(self, parent):
        """Create status bar"""
        status_frame = ttk.Frame(parent)
        status_frame.grid(row=2, column=0, sticky="ew", pady=(10, 0))
        status_frame.grid_columnconfigure(0, weight=1)
        
        # Status message
        status_label = ttk.Label(status_frame, textvariable=self.status_var)
        status_label.grid(row=0, column=0, sticky="w")
        
        # Current time
        time_label = ttk.Label(status_frame, textvariable=self.time_var)
        time_label.grid(row=0, column=1, sticky="e")

    # Helper methods
    def update_time(self):
        """Update time display"""
        current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.time_var.set(current_time)
        self.root.after(1000, self.update_time)
    
    def check_queues(self):
        """Check for updates from background threads"""
        try:
            # Check progress updates
            while not self.progress_queue.empty():
                progress_data = self.progress_queue.get_nowait()
                self.progress_var.set(progress_data.get('progress', 0))
                
                if 'message' in progress_data:
                    self.log_analysis_message(progress_data['message'])
            
            # Check status updates
            while not self.status_queue.empty():
                status_data = self.status_queue.get_nowait()
                self.status_var.set(status_data.get('message', ''))
        
        except queue.Empty:
            pass
        
        # Schedule next check
        self.root.after(100, self.check_queues)
    
    def validate_case_info(self):
        """Validate case information"""
        if not self.case_name.get().strip():
            messagebox.showerror("Error", "Please enter a case name")
            return False
        
        if not self.examiner_name.get().strip():
            messagebox.showerror("Error", "Please enter examiner name")
            return False
        
        if not self.extraction_path.get().strip():
            messagebox.showerror("Error", "Please select extraction path")
            return False
        
        if not Path(self.extraction_path.get()).exists():
            messagebox.showerror("Error", "Extraction path does not exist")
            return False
        
        return True
    
    def log_analysis_message(self, message):
        """Log message to analysis status"""
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        log_entry = f"[{timestamp}] {message}\n"
        self.analysis_status_text.insert(tk.END, log_entry)
        self.analysis_status_text.see(tk.END)
    
    def clear_analysis_log(self):
        """Clear analysis log"""
        self.analysis_status_text.delete("1.0", tk.END)
    
    def update_analysis_results(self, report):
        """Update GUI with analysis results"""
        self.analysis_results = report
        
        # Update evidence cards
        evidence_summary = report['evidence_summary']
        
        self.update_card_value("Messages", evidence_summary['communications']['messages'])
        self.update_card_value("Calls", evidence_summary['communications']['calls'])
        self.update_card_value("Photos", evidence_summary['multimedia']['photos'])
        self.update_card_value("Apps", evidence_summary['digital_activity']['app_data'])
        self.update_card_value("Locations", evidence_summary['digital_activity']['location_points'])
        
        # Calculate alerts based on configuration
        config_info = report.get('configuration_info', {})
        alerts = config_info.get('total_keywords', 0)
        self.update_card_value("Alerts", alerts)
        
        # Update executive summary
        self.update_executive_summary(report)
        
        # Switch to overview tab
        self.notebook.select(1)
        
        self.status_var.set("Integrated evidence analysis complete - review results")
    
    def update_card_value(self, card_name, value):
        """Update evidence card value"""
        if card_name in self.evidence_cards:
            card = self.evidence_cards[card_name]
            card.value_label.config(text=str(value))
    
    def update_executive_summary(self, report):
        """Update executive summary display"""
        self.executive_summary_text.delete("1.0", tk.END)
        
        exec_summary = report['executive_summary']
        config_info = report.get('configuration_info', {})
        
        summary_text = f"""INTEGRATED EVIDENCE ANALYSIS SUMMARY
{'-' * 50}

PRIORITY LEVEL: {exec_summary['priority_level']}
Reason: {exec_summary['priority_reason']}

EVIDENCE TYPES FOUND:
{chr(10).join(f'‚Ä¢ {evidence}' for evidence in exec_summary['evidence_types_found'])}

KEY STATISTICS:
‚Ä¢ Total Communications: {exec_summary['key_statistics']['total_communications']}
‚Ä¢ Unique Contacts: {exec_summary['key_statistics']['unique_contacts']}
‚Ä¢ Investigation Keywords: {exec_summary['key_statistics']['investigation_keywords']}
‚Ä¢ Multimedia Files: {exec_summary['key_statistics']['multimedia_files']}
‚Ä¢ Location Points: {exec_summary['key_statistics']['location_points']}

CONFIGURATION INTEGRATION:
‚Ä¢ Platform Detected: {config_info.get('platform_detected', 'Unknown')}
‚Ä¢ Active Modules: {', '.join(config_info.get('modules_used', []))}
‚Ä¢ Total Keywords Available: {config_info.get('total_keywords', 0)}

IMMEDIATE ACTIONS REQUIRED:
{chr(10).join(f'‚Ä¢ {action}' for action in exec_summary['immediate_actions'])}
"""
        
        # Add investigative leads
        leads = report.get('investigative_leads', [])
        if leads:
            summary_text += f"\nINVESTIGATIVE LEADS ({len(leads)}):\n"
            for i, lead in enumerate(leads[:5], 1):
                summary_text += f"{i}. {lead.get('type', 'Unknown')} - {lead.get('priority', 'Medium')}\n"
                summary_text += f"   {lead.get('description', 'No description')}\n"
                summary_text += f"   Action: {lead.get('action_required', 'No action specified')}\n\n"
        
        self.executive_summary_text.insert("1.0", summary_text)
    
    def analysis_complete(self):
        """Re-enable controls after analysis"""
        self.analyze_btn.config(state="normal")
        self.cancel_btn.config(state="disabled")
    
    def analysis_error(self, error_message):
        """Handle analysis errors"""
        messagebox.showerror("Analysis Error", error_message)
        self.status_var.set(f"Analysis failed: {error_message}")
        self.log_analysis_message(f"ERROR: {error_message}")
    
    def cancel_analysis(self):
        """Cancel current analysis"""
        if messagebox.askyesno("Cancel Analysis", "Cancel the current analysis?"):
            self.status_var.set("Analysis cancelled by user")
            self.analysis_complete()

    # Export methods (simplified for space - implement as needed)
    def export_messages_csv(self):
        messagebox.showinfo("Export", "Messages export functionality to be implemented")
    
    def export_calls_csv(self):
        messagebox.showinfo("Export", "Calls export functionality to be implemented")
    
    def export_contacts_csv(self):
        messagebox.showinfo("Export", "Contacts export functionality to be implemented")
    
    def export_multimedia_csv(self):
        messagebox.showinfo("Export", "Multimedia export functionality to be implemented")
    
    def export_locations_csv(self):
        messagebox.showinfo("Export", "Locations export functionality to be implemented")
    
    def export_executive_summary_txt(self):
        """Export executive summary with integration info"""
        if not self.analysis_results:
            messagebox.showinfo("Info", "No analysis data available for export")
            return
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
            title="Export Executive Summary"
        )
        
        if not filename:
            return
        
        try:
            generator = ForensicReportGenerator(
                self.case_name.get(),
                self.examiner_name.get(),
                self.analysis_results
            )
            
            report = generator.generate_executive_summary_report()
            
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(report)
            
            messagebox.showinfo("Success", f"Executive summary exported to {filename}")
            
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export executive summary: {e}")
    
    def export_detailed_report_txt(self):
        messagebox.showinfo("Export", "Detailed report export functionality to be implemented")
    
    def export_all_data_package(self):
        messagebox.showinfo("Export", "Data package export functionality to be implemented")
    
    def export_full_report(self):
        """Export full analysis report as JSON"""
        if not self.analysis_results:
            messagebox.showinfo("Info", "No analysis data available for export")
            return
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            title="Export Full Analysis Report"
        )
        
        if not filename:
            return
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(self.analysis_results, f, indent=2, default=str)
            messagebox.showinfo("Success", f"Full report exported to {filename}")
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export report: {e}")
    
    # Placeholder methods
    def export_app_data(self):
        messagebox.showinfo("Info", "App data export feature coming soon")
    
    def view_timeline(self):
        messagebox.showinfo("Info", "Timeline view feature coming soon")
    
    def view_map(self):
        messagebox.showinfo("Info", "Map view feature coming soon")
    
    def save_case(self):
        """Save case configuration with integration info"""
        if not self.validate_case_info():
            return
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            title="Save Case Configuration"
        )
        
        if not filename:
            return
        
        try:
            # Include integration configuration in save
            case_data = {
                'case_name': self.case_name.get(),
                'examiner_name': self.examiner_name.get(),
                'extraction_path': self.extraction_path.get(),
                'saved_date': datetime.datetime.now().isoformat(),
                'ghost_configuration': {
                    'modules_enabled': list(self.integration.get_analysis_modules_config().keys()),
                    'platform_detected': self.platform_var.get(),
                    'config_validation': self.integration.validate_configuration()
                }
            }
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(case_data, f, indent=2)
            
            messagebox.showinfo("Success", f"Case with configuration saved to {filename}")
            
        except Exception as e:
            messagebox.showerror("Save Error", f"Failed to save case: {e}")
    
    def load_case(self):
        """Load saved case configuration"""
        filename = filedialog.askopenfilename(
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            title="Load Case Configuration"
        )
        
        if not filename:
            return
        
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                case_data = json.load(f)
            
            # Load case information
            self.case_name.set(case_data.get('case_name', ''))
            self.examiner_name.set(case_data.get('examiner_name', ''))
            self.extraction_path.set(case_data.get('extraction_path', ''))
            
            # Load GHOST configuration if available
            ghost_config = case_data.get('ghost_configuration', {})
            if ghost_config:
                self.log_analysis_message(f"Loaded case with {len(ghost_config.get('modules_enabled', []))} configured modules")
            
            messagebox.showinfo("Success", "Case loaded successfully")
            
        except Exception as e:
            messagebox.showerror("Load Error", f"Failed to load case: {e}")
    
    def on_closing(self):
        """Handle application closing"""
        if self.analysis_thread and self.analysis_thread.is_alive():
            if messagebox.askyesno("Exit", "Analysis is running. Exit anyway?"):
                self.root.destroy()
        else:
            self.root.destroy()
    
    def run(self):
        """Start the GUI application"""
        self.root.mainloop()

def main():
    """Main function to start the integrated evidence analysis GUI"""
    print("[INFO] Starting GHOST Evidence Analysis Interface with Integration...")
    
    try:
        app = IntegratedEvidenceAnalysisGUI()
        app.run()
    except KeyboardInterrupt:
        print("\nApplication closed by user")
    except Exception as e:
        print(f"Application error: {e}")
        if 'messagebox' in globals():
            messagebox.showerror("Application Error", f"Failed to start application:\n{str(e)}")

if __name__ == "__main__":
    main()
